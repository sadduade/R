---
title: "HW 1. Tidyverse and visualizations"
output:
  pdf_document: default
  html_document: default
---

*Source: Olga Lyashevskaya, George Moroz, Alla Tambovtseva, and Ilya Schurov. Linguistic Data: Quantitative Analysis and Visualisation. The HSE course taught in MA programs in linguistics since 2015.*

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, error=TRUE)
```

### 0. О том, как выполнять это домашнее задание.

Это задание написано в формате R Markdown (.Rmd). Чтобы облегчить его проверку, мы просим вас писать код в блоки для кода на R, например,

```{r example}
# YOUR CODE HERE 
# (do not forget to remove #'s and all this text so that we could run the code)
```

и текст в блоки для текста. Пожалуйста, впишите ниже ваше имя и фамилию:

```
ELENA SADKOVA
```

Перед сдачей домашнего задания рекомендуем запустить `Run All` или сгенерировать html- или pdf-страницу с помощью `Knit`, чтобы убедиться, что в финальной версии весь ваш код будет запускаться без проблем.

Файл Rmd вы можете 
а) положить в свой **приватный** репозиторий `da4clcourse` на GitHub (в корне репозитория под именем `HW1.Rmd`). Дайте доступ преподавателю к приватному репозиторию (пригласите @olesar) или
б) выслать преподавателю на почту `olyashevskaya@hse.ru` с темой `da4clcourse`.


## 1. Частотность и фонетика

Во многих лингвистических исследованиях отмечается, что часто используемые в языке слова звучат короче, а при их произнесении наблюдается редукция и коартикуляция. Работа [Fabian Tomaschek et al.](https://www.semanticscholar.org/paper/Practice-makes-perfect-%3A-The-consequences-of-for-Tomaschek-Tucker/1e0dbc3787a6da84ffd4c3cae62f1340e4267694) (2018) исследует гипотезу, что моторные навыки произнесения улучшаются с опытом, который, в свою очередь, напрямую связан с частотностью слова. Ученые попросили испытуемых (17 бакалавров университета Тюбингена, 8 мужчин и 9 женщин) прочитать вслух немецкие глаголы, содержащие звук [a:] в основе. Испытуемые были поставлены в экспериментальные условия, которые исподволь заставляли их читать быстрее или медленнее (slow/fast condition).

В этом задании мы просим вас сравнить длину звучания всего слова целиком, а также длину звучания интересующего ученых сегмента (звука [a:]) в условиях slow и fast. Хотя логично предположить, что в условии fast произнесение и слов, и сегментов будет короче, все же нужно убедиться, что данные это подтверждают, прежде чем переходить к более сложному анализу по сути вопроса. Кроме того, мы будем уверены, что экспериментальные условия были должным образом соблюдены, ученые не запутались в кодировании данных и документировали результаты корректно.

**Интересующие нас переменные:**

-   `LogDurationW` - log-transformed word duration (логарифм длины произнесения слова)\
-   `LogDurationA` - log-transformed segment duration (логарифм длины произнесения сегмента)\
-   `Cond` - condition: slow vs. fast (условие).

### 1.0 Загрузка данных

Загрузите пакеты `tidyverse` и `skimr`. С помощью функции `read_csv` загрузите данные ([link](https://raw.githubusercontent.com/LingData2019/LingData2020/master/data/dur_word_frequency.csv)) в переменную `dur_word_freq` и используйте функции `summary()` и `skim()` (последняя из пакета `skimr`), чтобы изучить структуру данных тиббла.

```{r load-data}
library(tidyverse)
library(skimr)

dur_word_freq <- read.csv('https://raw.githubusercontent.com/LingData2019/LingData2020/master/data/dur_word_frequency.csv')

summary(dur_word_freq)
```
``` {r}
skim(dur_word_freq)
```

Какие базовые типы переменных (строковые, числовые (непрерывные), целочисленные, логические, комплексные) представляют данные в столбцах `dur_word_freq`?

```
  character            
  numeric    
  
```

### 1.1 Исследуем набор данных

Выведите уникальные значения в столбце `Lemma` с помощью функции `distinct()`.

```{r distinct}
distinct(dur_word_freq, Lemma)
```

### 1.2 Пропущенные значения

Давайте убедимся, что наши данные не содержат значений NA (а если содержат, то в каких столбцах). Используйте функции `map_int()` и `is.na()`, чтобы исследовать этот вопрос.

```{r is_na}
dur_word_freq %>%
  map_int(~sum(is.na(.)))
```

### 1.3 Данные как факторы

Факторы - это строковые переменные, закодированные числами (как levels) для экономии вычислительных ресурсов. Некоторые функции в R работают только с факторами, а некоторые методы чувствительны к порядку кодирования, поэтому перевод из строк в факторы иногда бывает полезен. Используя функции `mutate()` и `across()`, переведите все строковые переменные в столбцах в факторы, а затем посмотрите на структуру тиббла с помощью функции `str()`.

```{r mutate}
dur_word_freq %>%
  mutate(across(where(is.character), as.factor))
```

Догадайтесь, вспомните или прочитайте, по какому принципу кодируются факторы по умолчанию (подсказка: в переменной `Cond` значение `fast` имеет уровень 1, а `slow` имеет уровень 2)

```
ASCII
```

### 1.4 Усредненные длительности сегмента и слова

Сгруппировав данные по условию (`Cond`), выведите средние значения лог-трансформированных длин сегмента и слова примерно в таком виде (названия столбцов должны совпадать с данными в примере, округление числовых переменных может отличаться):

| Cond    | meanLogDurA | meanLogDurW |
|:--------|:------------|:------------|
| \<chr\> | \<dbl\>     | \<dbl\>     |
| fast    | -1.738072   | -0.5836253  |
| slow    | -1.628756   | -0.4483053  |

```{r summarise}
dur_word_freq %>%
  group_by(Cond) %>%
  summarise(AM = mean(LogDurationA),
            WM = mean(LogDurationW))
```

### 1.5 Больше описательных статистик для длительности сегмента и слова

Добавьте в таблицу 1.4 минимальные, максимальные и медианные значения для групп fast и slow (названия столбцов могут быть другими, чем в 1.4).

```{r summarise2}
dur_word_freq %>%
  group_by(Cond) %>%
  summarise(MeanA= mean(LogDurationA),
            MeanW = mean(LogDurationW),
            MinA = min(LogDurationA),
            MinW = min(LogDurationW),
            MaxA = max(LogDurationA),
            MaxW = max(LogDurationW),
            medianA = median(LogDurationA),
            medianW = median(LogDurationW))
```

### 1.6 Визуализации ggplot: график плотности (density plot)

О графике плотности распределения можно думать как о сглаженной гистограмме с большим числом столбцов. Раскомментируйте и запустите следующий код, который позволяет представить распределение непрерывных значений переменной `LogDurationA`, сгруппированных по переменной `Cond`.

Добавьте к этому коду тему `theme_classic()` и полупрозрачность (alpha = 0.5, указывается в геоме плотности).

```{r hist}
dur_word_freq %>%
  ggplot(aes(x = LogDurationA, group = Cond)) +
  geom_density(aes(fill = Cond), alpha = 0.5) 
  theme_classic()
```

### 1.7 Боксплот (базовый R)

Раскомментируйте и запустите следующий код.

```{r duration}
 boxplot(LogDurationA ~ Cond, data=dur_word_freq)
```

Результатом будут так называемые "ящики с усами" (*box and whisker plot*) для значений переменной `LogDurationA`, сгруппированным по переменной `Cond`. Больше об этом типе визуализаций можно прочесть в [Википедии](https://ru.wikipedia.org/wiki/Ящик_с_усами) (или [Английской Википедии](https://en.wikipedia.org/wiki/Box_plot). Сравните положение медианных значений `LogDurationA`, а также значений 1-го и 3-го квартиля в условиях fast и slow, запишите кратко ваши выводы ниже:

```
У Slow выше квартили и больше значение LogDurationA
Квартили SLOW: -1.5 ; -1.7
Квартили FAST: -1.6 ; -1.8
```

### 1.8. Боксплот в ggplot2

Для переменной `LogDurationW` представим боксплоты с помощью пакета `ggplot2`. Раскомментируйте и запустите код ниже. Измените (сделайте более понятными) подписи осей X и Y, добавьте тему `theme_classic()`. Необязательное задание - измените цвет заполнения боксплотов с помощью `scale_fill_brewer` из пакета `RColorBrewer` (палитра Dark2).

```{r boxplot-ggplot}
dur_word_freq %>%
 ggplot(aes(x=Cond, y=LogDurationW, fill=Cond)) +
 geom_boxplot() + 
 theme_classic() + 
 xlab('Условие') + 
 ylab('Логарифм длительности произнесения сегмента') +
 scale_fill_brewer(palette = "Dark2")
```

### 1.9

Аналогичным образом с помощью ggplot2 постройте боксплот для переменной `LogDurationA` (мы уже строили его с помощью базового R в 1.7).

```{r boxplot-ggplot2}
dur_word_freq %>%
 ggplot(aes(x=Cond, y=LogDurationA, fill=Cond)) +
 geom_boxplot() + 
 theme_classic() + 
 xlab('Условие') + 
 ylab('Логарифм длительности произнесения сегмента') +
 scale_fill_brewer(palette = "Dark2")
```

### 1.10. Скаттерплот в ggplot2

Постройте диаграмму рассеяния (= точечную диаграмму, геом `geom_point`) для переменных `LogDurationA` (по оси X) и `LogDurationW` (по оси Y). Используйте прозрачность 0.3. Добавьте на график регрессионную прямую (метод "lm").

```{r scatterplot}
dur_word_freq %>% 
  ggplot(aes(x=LogDurationA, y=LogDurationW)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  labs(title = "Geom_point",
       x = "Логарифм длительности произнесения сегмента",
       y = "Логарифм длительности произнесения слова")
```

Что можно сказать о связи между значениями длительности сегмента [a:] и длительности слова? Кратко и неформально сформулируйте свои выводы ниже:

```
Можно наблюдать линейную зависимость между ними
```

### 1.11 Длинный и короткий формат

Данные в наборе, с которым мы работаем, следуют "длинному" формату - каждой точке наблюдения соответствует своя строка. Отфильтруйте данные по условию "slow" и по значению "t" переменной `Exponent` (окончание глагольной формы), затем представьте их в широком формате таким образом, чтобы каждая строка представляла длительность произнесения разных слов одним испытуемым (см. фрагмент ниже).

| Participant | schab      | lahm       | bahn       |
|:------------|:-----------|:-----------|:-----------|
| \<chr\>     | \<dbl\>    | \<dbl\>    | \<dbl\>    |
| Art_02_S01  | -0.4768593 | -0.4471271 | -0.4085488 |
| Art_02_S03  | -0.4780197 | -0.5621014 | -0.5621014 |
| Art_02_S04  | -0.5798006 | -0.7550013 | -0.7133295 |

```{r wider}
dur_word_freq %>% 
  filter(Cond == 'slow',
         Exponent == 't') %>% 
  select(Participant, LogDurationW, Lemma) %>% 
  pivot_wider(names_from = Lemma,
              values_from = LogDurationW) -> wider_dur
wider_dur 
```

### 1.12

Выпишите глагол, для которого в заданных экспериментальных условиях нет данных минимум по двум испытуемым.

```
schlaf
```

Ваш код для этого задания:

```{r verb}
names(which(colSums(is.na(wider_dur)) > 1))
```
